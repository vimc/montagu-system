#!/usr/bin/env python3

import argparse
import os
import subprocess

def psql(sql):
    args = ['psql', '-U', 'vimc', '-d', 'montagu', '-c', sql]
    subprocess.run(args, check = True)

# It may be worthwhile setting the option 'synchronous_commit' to
# 'on' by adding the line
#
#   WITH (synchronous_commit = on)
#
# at the end of the CREATE SUBSCRIPTION block here.  We can also
# change this later with ALTER SUBSCRIPTION.
#
# https://www.postgresql.org/docs/10/static/sql-createsubscription.html
# https://www.postgresql.org/docs/10/static/runtime-config-wal.html#guc-synchronous-commit
def subscribe_start(d):
    # This can't be done in a transaction, which given what it does is
    # far from ideal!  If anything fails through this *will* leave the
    # db in an unfortunately state.
    #
    # The reason this level of shenanigans is required is that when
    # the subscription starts it will copy the data over.  This is
    # generally what we want as we want to reflect the master database
    # (and the first time it is run we must do this).  But if the sync
    # has already happened once then postgres will freak out trying to
    # do copy data into the table, violating all sorts of constraints.
    # So in otder to ensure that we reflect the master database we
    # have to remove all the data and to do that we need to suppress
    # the triggers on the burden_estimate_stochastic table.
    #
    # It might be possible to do this with *deferrable* fk checks
    # rather than disabling the triggers entirely
    #
    #    https://stackoverflow.com/a/38113838
    #
    # However, that defers until commit and we can't do that!  The
    # docs hint at a way of creating a replication slot directly using
    # "pg_create_logical_replication_slot with the plugin name
    # pgoutput) but there' no good guidance for that.
    sql1 = """
    ALTER TABLE burden_estimate_stochastic DISABLE TRIGGER ALL;
    DELETE FROM country;
    DELETE FROM burden_estimate_set;
    DELETE FROM burden_outcome;"""
    psql(sql)
    sql2 = """CREATE SUBSCRIPTION {subscription_name}
    CONNECTION 'dbname=montagu host={host} user=vimc password={password}'
    PUBLICATION {subscription_name};"""
    sql3 = "ALTER TABLE burden_estimate_stochastic ENABLE TRIGGER ALL;"
    psql(sql1)
    psql(sql2.format(**d))
    psql(sql3)

def subscribe_stop(d):
    sql = "DROP SUBSCRIPTION {subscription_name}"
    psql(sql.format(**d))

def publish_start(d):
    sql = """CREATE PUBLICATION {subscription_name}
    FOR TABLE burden_estimate_set, country, burden_outcome;"""
    psql(sql.format(**d))

def publish_stop(d):
    sql = "DROP PUBLICATION {subscription_name};"
    psql(sql.format(**d))

def run():
    parser = argparse.ArgumentParser(description="Start subscription")
    parser.add_argument('--host', type = str, default = 'db')
    parser.add_argument('--password', type = str, default = 'changeme')
    parser.add_argument('direction', choices = ['publish', 'subscribe'])
    parser.add_argument('action', choices = ['start', 'stop'])
    d = vars(parser.parse_args())
    d['subscription_name'] = 'sync_burden_estimate_set'
    if d['direction'] == 'publish':
        if d['action'] == 'start':
            publish_start(d)
        else:
            publish_stop(d)
    else:
        if d['action'] == 'start':
            subscribe_start(d)
        else:
            subscribe_stop(d)

if __name__ == "__main__":
    run()
